# Yelling at the Wind

A "platform" (lol) which provides for the following use-case:

_I'm a user with internet who has a thought to share. I'd like to share the
thought with the world anonymously and get some constructive feedback on it
within a few minutes._

## Views

The frontend has multiple views:

* Yell: An input box which takes in any text at all. The text will form the
  "yell" which others will hear using the Listen view
    * Yells have the following characteristics:
        * All caps, always
        * Emojiis definitely allowed
        * Newlines allowed
        * Monospace font
        * 1000 rune limit
        * Expire after 24h
    * There's a countdown showing how many runes have been used so far
    * There's a "Yell" button to send off the yell, which takes you to the Yell
      Stats view for that newly created yell

* History: Show's a list of non expired yells created by your device
    * Each entry in the list is a truncated summary of the yell's text, the
      timestamp the yell was created, and a button to delete it
    * Clicking an entry takes you to the Yell Stats page for the yell
    * There is a button to delete all yells

* Yell Stats: shows a view for a specific yell
    * Can only be accessed by the device which created the yell
    * Shows a timestamp of when the yell was created
    * Shows a count of the different reactions for the yell
    * Shows the text of the yell itself
    * Has a button which can be used to delete the Yell

* Listen: Allows you to "hear" other people's yells
    * Displays the text of one un-expired yell which your device hasn't shown
      you yet.
    * There are buttons for different reactions you can have to the yell. Each
      button is colored
        * "Nice!" (Green)
        * "I hear you" (Green)
        * "tldr" (Blue)
        * "k" (Blue)
        * "Not your best" (Purple?)
    * Upon reacting a new un-expired yell which your device hasn't shown you yet
      replaces the one just reacted to

## Concepts

These are the concepts which will be composed together to implement the views:

* Client: An entity with a stored public/private key-pair. Obviously the private
  key is never sent anywhere, the public key is used to identify the device. The
  Client also stores a small amount of other information, like generated
  YellIDs.
    * PublicKey
    * PrivateKey
    * Yells: map[YellID]TSCreated

* Permit: An opaque string provided by the backend which permits a device to
  make requests. Permits can be revoked at any time during any action, at which
  point it will be necessary to retrieve a new one.

* SignedPermit: A Permit which has been signed by the Client using it
    * Permit
    * TS
    * Signature

* Reaction:
    * ID
    * Color
    * Body

* Yell:
    * ID
    * PublicKey
    * Body
    * TSCreated
    * TSLastHeard
    * Reactions (never retrieved): map[PublicKey]ReactionID
    * ReactionsCount: map[ReactionID]uint64
    * Status (dynamic): ACTIVE, INACTIVE

## Actions

These are possible actions. Each has required arguments, a behavior for them,
and return values:

* RequestPermit:
    * Args: PublicKey, CaptchaStuff
    * Returns: Permit
    * Behavior: Generates and returns a new Permit for the PublicKey to use for
      all other requests. CaptchaStuff is always required to generate a new
      Permit.
    * Errors: ErrPermitDenied

* Yell:
    * Args: PublicKey, SignedPermit, Body
    * Returns: YellID
    * Behavior: Generates a YellID and stores the Yell object
    * Errors: ErrBodyMalformed

* GetYellsByPublicKey:
    * Args: PublicKey, SignedPermit
    * Returns: map[YellID]Yell
    * Behavior: Returns all Yells which the PublicKey has generated

* GetYellsByID:
    * Args: PublicKey, SignedPermit, []YellID
    * Returns: map[YellID]Yell
    * Behavior: Returns all Yells of the given IDs. Unknown Yells are not
      returned. Yells not generated by the PublicKey are not returned.

* Listen:
    * Args: PublicKey, SignedPermit
    * Returns: Yell, map[ReationID]Reaction
    * Behavior: Retrieves a Yell which a) hasn't expired, based on its
      TSCreated, b) hasn't been reacted to by PublicKey, based on Reactions, c)
      has the oldest TSLastHeard. Updates the TSLastHeard in the same step. Also
      returns available Reactions for the Yell
    * Errors: ErrNothingToHear

* React:
    * Args: PublicKey, SignedPermit, YellID, ReactionID
    * Returns: null
    * Behavior: Checks that the ReactionID is valid. Checks that the PublicKey
      isn't the creator of the Yell. Adds ReactionID to YellID's Reaction map,
      and increments the value for ReactionID in YellID's ReactionCount map
    * Errors: ErrUnknownYellID, ErrUnknownReactionID, ErrCreatorCantReact,
      ErrAlreadyReacted

* DeleteYells:
    * Args: PublicKey, SignedPermit, []YellID
    * Behavior: Uses the YellIDs to delete the full Yell objects out of
      the db
    * Returns: map[YellID]bool

## Permits

Permits serve a dual purpose. They are the mechanism by which the backend
ensures a Client is behaving honestly, and a part of the mechanism by which a
Client ensures it's not being impersonated. The latter purpose is fairly trivial
in implementation, so this section focuses on the former.

### Honest behavior

Honest behavior is indicated by behavior falling within an expected usage
pattern. This expected usage pattern is statically defined. If it was able to be
influenced by interaction with Clients themselves then it would be significantly
more abusable. It will never be possible to prevent a dishonest Client from
performing random actions which fall within the expected usage pattern, but we
can define the pattern so that doing so won't negatively harm the experience of
honest Clients.

Punishing dishonesty is difficult. Really the only way is to revoke the Permit
and make the Client get a new one, solving a captcha in the process. In effect
the worst punishment which can be offered is to make someone solve a captcha.
It's a universally terrible experience.

It's often easier to define dishonest behavior, and so the expected usage
pattern for this app is defined as the inverse of the expected usage pattern
of a dishonest Client

1) A dishonest Client wouldn't be able to prove it's human
2) A dishonest Client would perform actions for the purpose of degrading the
   service for others/increasing operational costs
3) A dishonest Client would never take a break from using the app
4) A dishonest Client would not take the time to read someone else's yell fully
5) A dishonest Client would not consider a yell's content before reacting
6) A dishonest Client would yell without wanting honest reactions

The rule 1 is implicitly handled. a Permit's existence implies that a human
solved at least one captcha at some point in the past and therefore proved it's
human, since the only way to obtain a Permit is to solve a captcha.

The rest of the rules will be handled by the backend implementation of Permits.

### Backend implementation

Each Permit has an associated object on the backend. If the object is not
present on the backend a new Permit must be obtained. Permits expire after some
period of not being used, probably a month.

Each backend Permit object keeps track of a small amount of statistics on a
per-action basis, each of these being an ActionStat:

* LastTS
* ... TODO

The backend Permit object looks like the following:

* Actions: map[Action]ActionStat
* LastActionTS
* TokenBucket
* TokenTax

TokenBucket is an integer which starts out at some large value, and for each
action taken some amount of tokens are removed from it. Each action has a token
cost associated with it. The bucket is slowly refilled with tokens over time at
a fixed rate. If all tokens are removed from the bucket the Permit is revoked.

TokenTax is an additional amount of tokens which are taken out of TokenBucket
for each action. The tax is increased based on indications that a Client isn't
being honest, and slowly decreased over time at a fixed rate.

In this way a Client acting honestly will deplete their TokenBucket at a more or
less expected rate, and the more dishonest they act the quicker the TokenBucket
is depleted. This implementation is nice because it has a good memory of
dishonesty via the TokenTax, which can't be tricked by, say, switching back and
forth between different actions. At the same time it's very small, not needing
to record individual actions which have occurred.

For each incoming action the Permit object is retrieved. If it's not in storage
ErrInvalidPermit is returned. At the end of the action the Permit is updated by
refilling the TokenBucket, decrementing the TokenTax, removing tokens from the
TokenBucket based on those new values in addition to input from the action (i.e.
action token cost, action tax increase). The Actions and LastActionTS fields are
also updated in this last step.

## TODO

* Inline TODOs
* Complete Permit system

## Future TODO

* Language support. So you can select what language your yell is in, and select
  which languages you are able to listen to
* Maintenance updates on frontend
